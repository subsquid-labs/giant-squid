type Account @entity {
  id: ID!
  transfers: [AccountTransfer!] @derivedFrom(field: "account")
  rewards: [Reward!] @derivedFrom(field: "account")
  bonds: [Bond!] @derivedFrom(field: "account")
  stakeWithdrawals: [Withdrawal!] @derivedFrom(field: "account")
  #stakingInfo: Staker @derivedFrom(field: "stash")
  ownedDApps: [DAppContract!] @derivedFrom(field: "developer")
  lastUpdateBlock: Int!
}

# TRANSFERS 

enum TransferDirection {
  From
  To
}

interface Action {
  timestamp: DateTime
  blockNumber: Int
  extrinsicHash: String
}

interface CanFail {
  success: Boolean
}

type Transfer implements Action & CanFail @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String! @index
  to: TransferLocation
  from: TransferLocation!
  asset: TransferAsset!
  success: Boolean! @index
  type: TransferType!
}

union TransferLocation = TransferLocationAccount | TransferLocationEvm | TransferLocationXcm

type TransferLocationAccount {
  id: String!
}

type TransferLocationEvm {
  address: String!
}

union TransferAsset = TransferAssetToken | TransferAssetMultiToken

enum TransferType {
  Native
  Contribution
  Xcm
}

type TransferAssetToken {
  symbol: String
  amount: BigInt
}

type TransferAssetMultiToken {
  tokens: [TransferAssetToken]
}

type TransferLocationXcm {
  id: String
  paraId: Int
}

type AccountTransfer @entity {
  id: ID!
  transfer: Transfer
  account: Account!
  direction: TransferDirection
}

# DAPPSTAKING

type Staker @entity {
  id: ID! #stash Id
  stashId : ID!
  stash: Account! # @unique
  activeBond: BigInt! # only staked
  unbondingVolume: BigInt! # unstaked but not yet withdrawn
  totalReward: BigInt!
  stakeStates: [DAppStakeState!] @derivedFrom(field:"staker")
  rewards: [Reward!] @derivedFrom(field: "staker")
  bonds: [Bond!] @derivedFrom(field: "staker")
  activeStakedApps: [DAppStakeState!] @derivedFrom(field: "staker")
}

interface HasEra {
  era: Era!
}


enum RewardReceiver {
  DAPP
  STAKER
}

type Reward implements Action & HasEra @entity  {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int @index
  extrinsicHash: String @index
  accountId: ID!
  account: Account!
  amount: BigInt!
  era: Era!
  stakerId: ID!
  staker: Staker!
  receiverType: RewardReceiver!
  contract: DAppContract!
}

type Withdrawal implements Action @entity {
  id: ID!
  timestamp: DateTime
  blockNumber: Int @index
  extrinsicHash: String @index
  accountId: ID!
  account: Account!
  amount: BigInt
}


type DAppStakeState @entity {
  id: ID!
  staker: Staker!
  contract: DAppContract!
  stakeVolume: BigInt!
}

enum BondType {
  Bond
  Unbond
}

type Bond implements Action @entity  {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int @index
  extrinsicHash: String @index
  accountId: ID!
  account: Account!
  amount: BigInt!
  type: BondType!
  stakerId: ID!
  staker: Staker!
  contract: DAppContract!
}

type Era @entity {
  id: ID!
  index: Int!
  timestamp: DateTime!
  startedAt: Int!
  totalStakerRewardsReceived: BigInt!
  totalAppsRewardsReceived: BigInt!
  rewards: [Reward!] @derivedFrom(field: "era")
}

enum DAppState {
  REGISTERED
  UNREGISTERED
}

type DAppContract @entity {
  id: ID!
  developerId: ID!
  developer: Account!
  bondHistory: [Bond!] @derivedFrom(field: "contract")
  activeStake: BigInt!
  stakers: [DAppStakeState!] @derivedFrom(field: "contract")
  state: DAppState!
}
